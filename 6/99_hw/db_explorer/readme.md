Программа db_explorer

Эта простой веб-сервис будет представлять собой менеджер MySQL-базы данных, который позволяет осуществлять CRUD-запросы (create, read, update, delete) к ней по HTTP

В данном задании мы продолжаем отработку навыков работы с HTTP и взаимодействуем с базой данных.

*В это задании нельзя использовать глобальные переменные, нужное вам храните в полях структуры, которая живёт в замыкании*

Для пользователя это выглядит так:
* GET / - возвращает список всех таблиц
    ```sql
    SHOW TABLES;
    ```
    Ответ:
    ```json
    {
        "response": {
            "tables": ["items", "users"]
        }
    }
    ```

* GET /$table?limit=5&offset=7 - возвращает список записей из таблицы
    ```sql
    SELECT * FROM items LIMIT 5 OFFSET 7;
    ```
    Ответ:
    ```json
    {
        "response": {
            "records": [
                {
                    "id": 1,
                    "title": "database/sql",
                    "description": "Рассказать про базы данных",
                    "updated": "rvasily"
                },
                {
                    "id": 2,
                    "title": "memcache",
                    "description": "Рассказать про мемкеш с примером использования",
                    "updated": null
                }
            ]
        }
    }
    ```

* GET /$table/$id - возвращает информацию о записи
    ```sql
    SELECT * FROM users WHERE user_id = 1;
    ```
    Ответ:
    ```json
    {
        "response": {
            "record": {
                "user_id": 1,
                "login": "rvasily",
                "password": "love"
            }
        }
    }
    ```

* PUT /$table - создаёт новую запись
    ```sql
    INSERT INTO users (login, password, email, info) VALUES (?, ?, ?, ?);
    ```
    Запрос:
    ```json
    {
        "login": "qwerty'",
        "password": "love\"",
        "email": "",
        "info": ""
    }
    ```
    Ответ:
    ```json
    {
        "response": {
            "user_id": 2
        }
    }
    ```

* POST /$table/$id - обновляет запись
    ```sql
    UPDATE users SET info = ?, updated = ? WHERE user_id = ?;
    ```
    Запрос:
    ```json
    {
        "info": "try update",
        "updated": "now"
    }
    ```
    Ответ:
    ```json
    {
        "response": {
            "updated": 1
        }
    }
    ```

* DELETE /$table/$id - удаляет запись
    ```sql
    DELETE FROM items WHERE id = ?;
    ```
    Ответ:
    ```json
    {
        "response": {
            "deleted": 1
        }
    }
    ```

Ошибки возвращаются в формате:
```json
{
    "error": "unknown table"
}
```
или
```json
{
    "error": "record not found"
}
```
или
```json
{
    "error": "field id have invalid type"
}
```

Особенности работы программы:
* Роутинг запросов - руками, никаких внешних библиотек использовать нельзя.
* Полная динамика. при инициализации в NewDbExplorer считываем из базы список таблиц, полей (запросы ниже), далее работаем с ними при валидации. Никакого хадкода в виде кучи условий и написанного кода для валидации-заполнения. Если добавить третью таблицу - всё должно работать для неё.
* Считаем что во время работы программы список таблиц не меняется
* Запросы придётся конструировать динамически, данные оттуда доставать тоже динамически - у вас нет фиксированного списка параметров - вы его подгружаете при инициализации.
* Валидация на уровне "string - int - float - null", без заморочек. Помните, что json в пустой итнерфейс распаковывает как float, если не указаны спец. опции.
* Вся работа происходит через database/sql, вам на вход передаётся рабочее подключение к базе. Никаких orm и прочего.
* Все имена полей так как они в базе.
* В случае если возникает ошибка - просто возвращаем 500 в http-статусе
* Не забывайте про SQL-инъекции
Неизвестные поля игнорируем
* В этом задании запрещено использование глобальных переменных. Всё что вы хотите хранить - храните в полях структуры, которая живёт в замыкании

Запросы вам в помощь для получения списка таблицы и их структуры:
``
SHOW TABLES;
SHOW FULL COLUMNS FROM `$table_name`;
``

Подсказки:
* Внутри row, который вы получаете из базы лежат не только сами значения полей, но и метаданные - https://golang.org/pkg/database/sql/#Rows.ColumnTypes
* Тут будут активно применяться пустые интерфейсы
* Обратите внимание на обработку null-значения ( это когда вам не приходит значение переменной, для которой нет дефолта в базе - там буде такой тест-кейс)
* Придётся вытаскивать неизвестное количество полей из row, подумайте как тут можно применить пустые интерфейсы
* Поднять mysql-базу локально проще всего через докер:

```linux
docker run -p 3306:3306 -v $(PWD):/docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=golang -d mysql
```

```windows
docker run -p 3306:3306 -v %cd%:/docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=golang -d mysql
```

## Маршрутизация запросов

Сервис обрабатывает следующие типы запросов:

### GET запросы
1. `GET /` 
   - Показывает список всех таблиц
   - Не принимает параметров
   - Использует запрос `SHOW TABLES`

2. `GET /$table`
   - Показывает записи из таблицы
   - Параметры:
     * limit - ограничение выборки (по умолчанию 5)
     * offset - смещение от начала (по умолчанию 0)
   - Использует запрос `SELECT * FROM table LIMIT ? OFFSET ?`

3. `GET /$table/$id`
   - Показывает одну запись из таблицы
   - Использует запрос `SELECT * FROM table WHERE primary_key = ?`

### Модификация данных
1. `PUT /$table`
   - Создает новую запись
   - Игнорирует primary key в теле запроса
   - Автоматически заполняет NOT NULL поля пустыми значениями
   - Возвращает ID созданной записи

2. `POST /$table/$id`
   - Обновляет существующую запись
   - Нельзя изменять primary key
   - Игнорирует неизвестные поля
   - Возвращает количество обновленных записей

3. `DELETE /$table/$id`
   - Удаляет запись по ID
   - Возвращает количество удаленных записей

### Коды ответов
- 200 - успешное выполнение
- 404 - таблица/запись не найдена
- 400 - неверный тип данных или попытка изменить primary key
- 500 - ошибка базы данных

### Безопасность
- Все запросы экранируются от SQL-инъекций
- Имена таблиц и полей оборачиваются в backticks
- Значения передаются через prepared statements
- Неизвестные поля игнорируются

## Правила маршрутизации

Разбор URL и определение типа запроса происходит по следующим правилам:

1. `GET /`
   - Паттерн: точное совпадение "/"
   - Параметры: нет
   - Пример: `GET /`

2. `GET /$table`
   - Паттерн: один сегмент после "/"
   - Параметры запроса (опциональные):
     * limit (по умолчанию 5)
     * offset (по умолчанию 0)
   - Примеры:
     * `GET /users`
     * `GET /users?limit=10`
     * `GET /users?offset=20`
     * `GET /users?limit=10&offset=20`

3. `GET /$table/$id`
   - Паттерн: два сегмента после "/"
   - Параметры: нет
   - Пример: `GET /users/42`

4. `PUT /$table`
   - Паттерн: один сегмент после "/"
   - Тело запроса: JSON объект с полями записи
   - Пример: `PUT /users`

5. `POST /$table/$id`
   - Паттерн: два сегмента после "/"
   - Тело запроса: JSON объект с обновляемыми полями
   - Пример: `POST /users/42`

6. `DELETE /$table/$id`
   - Паттерн: два сегмента после "/"
   - Параметры: нет
   - Пример: `DELETE /users/42`

### Алгоритм определения типа запроса:

1. Разбить URL по символу "/"
2. Подсчитать количество сегментов (n)
3. Определить метод запроса (method)
4. Выбрать обработчик по правилу:
   - Если n=0 и method=GET -> список таблиц
   - Если n=1 и method=GET -> записи таблицы
   - Если n=2 и method=GET -> одна запись
   - Если n=1 и method=PUT -> создание записи
   - Если n=2 и method=POST -> обновление записи
   - Если n=2 и method=DELETE -> удаление записи
   - Иначе -> 404 ошибка